/*

    {{ warn }}

    Domain: {{ domain.name }}
{% if 'desc' in domain %}
    Description: {{ domain.desc }}
{% endif %}
*/

#pragma once

#include <iostream>
#include <string>
#include <vector>
#include <optional>
#include <chrono>
#include <sstream>
#include <iomanip>

namespace loglab_{{ domain.name }}
{
    class LogSerializer {
    public:

        static std::string FormatDateTime() {
            auto now = std::chrono::system_clock::now();
            auto in_time_t = std::chrono::system_clock::to_time_t(now);
            auto microseconds = std::chrono::duration_cast<std::chrono::microseconds>(now.time_since_epoch()) % 1000000;

            char datetime_buffer[64];
{% if utc %}
            std::tm* tm_time = std::gmtime(&in_time_t);
            std::sprintf(datetime_buffer, "%04d-%02d-%02dT%02d:%02d:%02d.%06ldZ",
                tm_time->tm_year + 1900, tm_time->tm_mon + 1, tm_time->tm_mday,
                tm_time->tm_hour, tm_time->tm_min, tm_time->tm_sec,
                microseconds.count());
{% else %}
            std::tm* tm_time = std::localtime(&in_time_t);
            int len = std::sprintf(datetime_buffer, "%04d-%02d-%02dT%02d:%02d:%02d.%06ld",
                tm_time->tm_year + 1900, tm_time->tm_mon + 1, tm_time->tm_mday,
                tm_time->tm_hour, tm_time->tm_min, tm_time->tm_sec,
                microseconds.count());

            // Add timezone offset for local time
            long offset = tm_time->tm_gmtoff;
            int hours = offset / 3600;
            int minutes = abs(offset % 3600) / 60;
            std::sprintf(datetime_buffer + len, "%+03d:%02d", hours, minutes);
{% endif %}

            return std::string(datetime_buffer);
        }
    };

{% for name, elst in events.items() %}
{% set edata = elst[-1] %}
{% set edef = edata[1] %}
    /// <summary>
    ///  {{ edef.desc }}
    /// </summary>
    class {{ name }}
    {
    public:
        static constexpr const char* Event = "{{ name }}";

        // Required fields
{% for fname, flst in (edef.fields|required).items() %}
{% set fdata = flst[-1] %}
{% set fdef = fdata[1] %}
        // {{ fdef.desc }}
        {{ type(fdef) }} {{ fname }};
{% endfor %}

        // Optional fields
{% for fname, flst in (edef.fields|optional).items() %}
{% set fdata = flst[-1] %}
{% set fdef = fdata[1] %}
        // {{ fdef.desc }}
        std::optional<{{ type(fdef) }}> {{ fname }};
{% endfor %}

        {{ name }}() {}

        {{ name }}({% for fname, flst in (edef.fields|required).items() %}{% set fdata = flst[-1] %}{% set fdef = fdata[1] %}{{ type(fdef) }} _{{ fname }}{% if not loop.last %}, {% endif %}{% endfor %})
        {
            reset({% for fname, flst in (edef.fields|required).items() %}_{{ fname }}{% if not loop.last %}, {% endif %}{% endfor %});
        }

        void reset({% for fname, flst in (edef.fields|required).items() %}{% set fdata = flst[-1] %}{% set fdef = fdata[1] %}{{ type(fdef) }} _{{ fname }}{% if not loop.last %}, {% endif %}{% endfor %})
        {
{% for fname, flst in (edef.fields|required).items() %}
            {{ fname }} = _{{ fname }};
{% endfor %}
{% for fname, flst in (edef.fields|optional).items() %}
            {{ fname }}.reset();
{% endfor %}
        }

        std::string serialize()
        {
            std::stringstream ss;
            ss << "{";

            // DateTime and Event
            ss << "\"DateTime\":\"" << LogSerializer::FormatDateTime() << "\",";
            ss << "\"Event\":\"" << Event << "\"";

            // Required fields
{% for fname, flst in (edef.fields|required).items() %}
{% set fdef = flst[-1][1] %}
            ss << ",";
            ss << "\"{{ fname }}\":";
{% if type(fdef) == 'std::string' %}
            ss << "\"" << {{ fname }} << "\"";
{% elif type(fdef) == 'bool' %}
            ss << ({{ fname }} ? "true" : "false");
{% else %}
            ss << {{ fname }};
{% endif %}
{% endfor %}

            // Optional fields
{% for fname, flst in (edef.fields|optional).items() %}
{% set fdef = flst[-1][1] %}
            if ({{ fname }}.has_value())
            {
                ss << ",";
                ss << "\"{{ fname }}\":";
{% if type(fdef) == 'std::string' %}
                ss << "\"" << {{ fname }}.value() << "\"";
{% elif type(fdef) == 'bool' %}
                ss << ({{ fname }}.value() ? "true" : "false");
{% else %}
                ss << {{ fname }}.value();
{% endif %}
            }
{% endfor %}

            // Const fields
{% for fname, finfo in (edef.fields|const).items() %}
            ss << ",";
            ss << "\"{{ fname }}\":";
{% set ftype = finfo[0] %}
{% set fval = finfo[1] %}
{% if ftype == 'string' %}
            ss << "\"" << {{ fval }} << "\"";
{% else %}
            ss << {{ fval }};
{% endif %}
{% endfor %}

            ss << "}";
            return ss.str();
        }
    };
{% endfor %}
}
